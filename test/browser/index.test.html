<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <div id="root"></div>
    <script>
      class Tester {
        _isAutomated = window.navigator.webdriver

        sendId = 0
        _description
        stats = { error: 0, warn: 0, success: 0 }
        tests = []

        end() {
          const total = this.stats.error + this.stats.warn + this.stats.success
          const success = this.stats.success

          setTimeout(() => {
            this.sendToPuppeteer('\n' + this.indent + this.clr.lightGreen(`${success}/${total} passing\n`))
            const done = document.createElement('div')
            done.innerText = 'done'
            done.id = 'done'
            document.body.appendChild(done)
          }, 100)
        }

        async test() {
          for (let i = 0; i < this.tests.length; i++) {
            const { description, fnc } = this.tests[i]
            this._description = description
            await fnc()
          }
          this.end()
        }

        description(description, fnc) {
          this.tests.push({ description, fnc })
        }

        async wait(ms = 100) {
          return new Promise(resolve => {
            setTimeout(() => {
              resolve()
            }, ms)
          })
        }

        error(assertion, message = 'No Description') {
          if (assertion === true) {
            this.stats.success++
            this.sendSuccess(message)
          } else {
            this.stats.error++
            this.sendError(message, assertion)
          }
        }

        get indent() {
          return '  '
        }

        get sym() {
          return {
            fail: '✘',
            pass: '✔'
          }
        }

        get clr() {
          return {
            red: text => `\u001b[31m${text}\u001b[0m`,
            green: text => `\u001b[32m${text}\u001b[0m`,
            lightGreen: text => `\u001b[32;1m${text}\u001b[0m`,
            gray: text => `\u001b[90m${text}\u001b[0m`
          }
        }

        title(title) {}

        sendSuccess(msg, assertion) {
          const symbol = this.clr.lightGreen(this.sym.pass)
          const message = this.clr.gray(msg)
          this.sendToPuppeteer(`${this.indent}${symbol} ${message}`)
        }

        sendError(msg, assertion) {
          const error = this.clr.red(`${this.sym.fail} ${msg}`)
          const description = this.clr.gray(`${this.indent}${this._description}`)
          this.sendToPuppeteer(`\n${this.indent}${error}\n${this.indent}${description}\n`)
        }

        sendToPuppeteer(msg) {
          if (!this._isAutomated) {
            console.log(msg.replace(/;1/, ''))
            return
          }

          fetch('http://localhost:8080/data', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ text: msg, id: this.sendId++ })
          })
        }
      }

      const test = new Tester()
    </script>

    <script src="/bundles/nano.instrumented.min.js"></script>
    <script>
      const { h, render, Component, withStyles } = nanoJSX
    </script>

    <script type="module">
      test.description('Simple Test', async () => {
        const App = () => {
          return h('div', { id: 'root' }, h('h1', {}, 'Hello Nano'))
        }

        render(App, document.getElementById('root'))

        const hello = document.querySelector('h1')
        test.error(hello.innerText === 'Hello Nano', `Should get "Hello Nano", got ${hello.innerText}`)
      })

      // similar to /test/nodejs/props.test.tsx
      test.description('Props', async () => {
        const SingleName = props => {
          return h('li', null, `${props.name} - ${props.children}`)
        }

        const NameList = props => {
          const list = props.names.map(name => h(SingleName, { name: name }, name))
          return h('ul', null, list)
        }

        const Root = props => {
          const h1 = h('h1', null, 'List of all names:')
          return h('div', { id: 'name-list' }, h1, h(NameList, { ...props }))
        }

        const html = render(h(Root, { names: ['Doe', 'Suzanne'] }))

        const h1 = html.querySelector('h1').innerText
        const firstName = html.querySelector('ul').firstChild.outerHTML

        test.error(h1 === 'List of all names:', `Should get "List of all names:", got ${h1}`)
        test.error(firstName === '<li>Doe - Doe</li>', `Should get "<li>Doe - Doe</li>", got ${firstName}`)
      })

      test.description('withStyles', async () => {
        class AppA extends Component {
          render() {
            return h('div', null, h('p', { class: 'colored' }, 'with styles'))
          }
        }
        const App = withStyles(
          '.colored { background-color: lightblue; }',
          () => '.colored { padding: 12px; border: 4px black solid; } ',
          { toString: () => '.colored { font-family: monospace; }' }
        )(AppA)

        render(h(App), document.getElementById('root'))

        await test.wait()

        // get those 3 head elements
        const head = Array.from(document.head.querySelectorAll('style')).slice(0, 3)
        const colored = document.querySelector('.colored')

        test.error(/^<style>.colored { background/.test(head[0].outerHTML), 'Should add styles')
        test.error(/ily: monospace; }<\/style>$/.test(head[2].outerHTML), 'Should add styles')
      })

      test.test()
    </script>
  </body>
</html>
